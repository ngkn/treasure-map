{"version":3,"sources":["context/gameContext.tsx","utils/helpers/map/movements.ts","components/Map/index.tsx","utils/helpers/map/index.ts","components/Output/index.tsx","utils/helpers/form/index.ts","utils/validations/regex/index.ts","components/Form/FormInstructions.tsx","pages/App.tsx","utils/helpers/outputResult/index.ts","reportWebVitals.ts","index.tsx"],"names":["GameContext","createContext","useGame","useContext","GameProvider","children","useState","widthMap","setWidthMap_","lengthMap","setLengthMap_","mountains","setMountains_","treasures","setTreasures_","adventurers","setAdventurer_","isAlreadyAMap","setisAlreadyAMap_","Provider","value","setWidthMap","number","setLengthMap","setMountains","mountain","setTreasures","treasure","setAdventurers","adventurer","getRemainingMoves","total","map","movements","length","reduce","a","b","setisAlreadyAMap","boolean","filterMovement","mapCopy","adventurersWithMovementForward","adventurersCopy","adventurersWithMovementForwardCopy","mapClone","adventurersClone","treasuresClone","adventurersThatWillMove","nextCoords","forEach","adventurerCopy","orientation","horizontally","vertically","nextMove","id","String","priority","previousValue","currentValue","set","get","concat","Map","values","array","checkDuplicateMove","adventurerMove","adventurerAfterMoved","moveForward","adventurerOldCoords","mapBox","mapBoxAfterMoved","mapBoxOldCoords","isAdventurer","type","substring","treasureRecovered","idTreasure","symbol","name","x","y","handleResult","mapDefault","Array","fill","_","__","setMap","remaininMoves","setRemaininMoves","useEffect","newMap","addMountain","addTreasure","addAdventurer","setTimeout","firstMovement","slice","newOrientation","changeOrientation","moveAdventurers","clearTimeout","className","items","indexFirst","subItems","sIndex","uuid","Output","elementsOutput","mapLine","mountainsLine","treasuresLine","adventurersLine","stringToArray","line","split","filter","Boolean","instructionsValidation","instructions","instructionsCopy","mapLineInstruction","shift","mapValid","mapInstruction","instructionsTotal","mapSize","isMapStructureValid","test","mapInstructionArray","firstNumber","Number","secondNumber","width","mapInstructionValidation","Object","keys","elementsValid","elementsInstructions","isElementsValid","mountainsCoords","treasuresCoords","adventurerCoords","mapLineInstructionArray","mapInstructionWidthNumber","mapInstructionLengthNumber","coordsElements","instruction","index","coords","elementInstruction","isMapInstruction","isAdventurerInstruction","isMountainInstruction","isTreasureInstruction","isMountainStructureValid","isTreasureStructureValid","isAdventurerStructureValid","element","validateAdventurer","isOneStructureValid","isMountainOrTreasureOutOfMapCoords","isAdventurerOutOfMapCoords","indexHorizontally","indexVertically","push","some","item","indexOf","isValid","elementsInstructionsValidation","FormInstructions","handleMapCreation","resetResult","refTextArea","useRef","createMap","setCreateMap","onSubmit","event","current","REGEX_DETECT_WHITESPACE","replace","instructionsToArray","preventDefault","cols","rows","ref","App","displayMap","setDisplayMap","displayResult","setDisplayResult","setElementsOutput","isInstructionsValid","mapElements","mapElementsOutput","getResults","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.79f6ecfd.chunk.js","sourcesContent":["import { createContext, ReactNode, useContext, useState } from 'react'\n\nimport GameContextType from 'interfaces/GameContextType'\nimport MountainType from 'interfaces/MountainType'\nimport TreasureType from 'interfaces/TreasureType'\nimport AdventurerType from 'interfaces/AdventurerType'\n\nconst GameContext = createContext<GameContextType>(null!)\n\nexport function useGame() {\n  return useContext(GameContext)\n}\n\nexport function GameProvider({ children }: { children: ReactNode }) {\n  const [widthMap, setWidthMap_] = useState<number>(0)\n  const [lengthMap, setLengthMap_] = useState<number>(0)\n  const [mountains, setMountains_] = useState<MountainType[]>([])\n  const [treasures, setTreasures_] = useState<TreasureType[]>([])\n  const [adventurers, setAdventurer_] = useState<AdventurerType[]>([])\n\n  const [isAlreadyAMap, setisAlreadyAMap_] = useState(false)\n\n  function setisAlreadyAMap(boolean: boolean) {\n    setisAlreadyAMap_(boolean)\n  }\n\n  function setWidthMap(number: number) {\n    setWidthMap_(number)\n  }\n\n  function setLengthMap(number: number) {\n    setLengthMap_(number)\n  }\n\n  function setMountains(mountain: MountainType[]) {\n    setMountains_(mountain)\n  }\n\n  function setTreasures(treasure: TreasureType[]) {\n    setTreasures_(treasure)\n  }\n\n  function setAdventurers(adventurer: AdventurerType[]) {\n    setAdventurer_(adventurer)\n  }\n\n  function getRemainingMoves() {\n    let total\n    if (adventurers) {\n      const moves = adventurers.map((adventurer) => adventurer.movements.length)\n\n      total = moves.reduce((a, b) => a + b, 0)\n    }\n    return total || 0\n  }\n\n  return (\n    <GameContext.Provider\n      value={{\n        widthMap,\n        lengthMap,\n        mountains,\n        treasures,\n        adventurers,\n        isAlreadyAMap,\n        setWidthMap,\n        setLengthMap,\n        setMountains,\n        setTreasures,\n        setAdventurers,\n        getRemainingMoves,\n        setisAlreadyAMap,\n      }}\n    >\n      {children}\n    </GameContext.Provider>\n  )\n}\n","/* eslint-disable no-param-reassign */\nimport AdventurerType from 'interfaces/AdventurerType'\nimport MapType from 'interfaces/MapType'\nimport MoveAdventurersType from 'interfaces/MoveAdventurersType'\nimport NextCoordsType from 'interfaces/NextCoordsType'\nimport TreasureType from 'interfaces/TreasureType'\n\n/**\n * Verify if there are adventurers that will go on the same next case\n * If this is the case, it filters and keep adventurers with high priority to move this turn\n *\n * @param {Array} adventurersWithMovementForward adventurers with \"A\" in movement this turn\n *\n * @returns {Array} adventurers that will move this turn based on their priority\n */\nexport function checkDuplicateMove(adventurersWithMovementForward: AdventurerType[]) {\n  let nextCoords: NextCoordsType = []\n  const adventurersWithMovementForwardCopy = [...adventurersWithMovementForward]\n\n  // Adventurers array with their future coords\n  adventurersWithMovementForwardCopy.forEach((adventurer) => {\n    const adventurerCopy = { ...adventurer }\n\n    if (adventurerCopy.orientation === 'N') {\n      adventurerCopy.horizontally -= 1\n    }\n    if (adventurerCopy.orientation === 'S') {\n      adventurerCopy.horizontally += 1\n    }\n\n    if (adventurerCopy.orientation === 'E') {\n      adventurerCopy.vertically += 1\n    }\n    if (adventurerCopy.orientation === 'O') {\n      adventurerCopy.vertically -= 1\n    }\n\n    const nextMove = {\n      id: adventurer.id,\n      nextMove: String(adventurerCopy.horizontally) + String(adventurerCopy.vertically), // String to compare duplicate later\n      priority: adventurer.priority,\n    }\n\n    nextCoords = [...nextCoords, nextMove]\n  })\n\n  // Regroup adventurers that will go in the same case in different groups\n  const isDuplicates = [\n    ...nextCoords\n      .reduce(\n        (previousValue: any, currentValue: any) =>\n          previousValue.set(\n            currentValue.nextMove,\n            (previousValue.get(currentValue.nextMove) || []).concat(currentValue),\n          ),\n        new Map(),\n      )\n      .values(),\n  ]\n\n  // Keep all adventurers that will move this turns\n  const adventurersPriority = isDuplicates.map((array) => {\n    const adventurersThatWillMove = array.reduce(function (previousValue: any, currentValue: any) {\n      return currentValue.priority < previousValue.priority ? currentValue : previousValue\n    })\n\n    return adventurersThatWillMove\n  })\n\n  return adventurersPriority\n}\n\n/**\n * Verify if there are adventurers that will go on the same next case\n * If this is the case, it filters and keep adventurers with high priority to move this turn\n *\n * @param {AdventurerType} adventurer adventurer object\n * @param {AdventurerType} widthMap width of map\n * @param {AdventurerType} lengthMap length of map\n *\n * @returns {AdventurerType} adventurer with new coords after move forward\n */\nexport function moveForward(adventurer: AdventurerType, widthMap: number, lengthMap: number) {\n  const adventurerCopy = { ...adventurer }\n\n  if (adventurerCopy.orientation === 'N') {\n    if (adventurerCopy.horizontally > 0) adventurerCopy.horizontally -= 1\n  }\n  if (adventurerCopy.orientation === 'S') {\n    if (adventurerCopy.horizontally < widthMap - 1) adventurerCopy.horizontally += 1\n  }\n  if (adventurerCopy.orientation === 'E') {\n    if (adventurerCopy.vertically < lengthMap - 1) adventurerCopy.vertically += 1\n  }\n  if (adventurerCopy.orientation === 'O') {\n    if (adventurerCopy.vertically > 0) adventurerCopy.vertically -= 1\n  }\n\n  return adventurerCopy\n}\n\n/**\n * Update informations about map, adventurers, treasures depend on adventurer move\n *\n * @param {MapType} mapCopy map array multidimensional\n * @param {AdventurerType} adventurersWithMovementForward adventurers with \"A\" for movement\n * @param {AdventurerType} adventurersCopy adventurers array\n * @param {TreasureType} treasures treasures array\n * @param {number} widthMap width of map\n * @param {number} lengthMap length of map\n *\n * @returns {MapType, AdventurerType} new map and adventurers array after move\n */\nexport function filterMovement(\n  mapCopy: MapType,\n  adventurersWithMovementForward: AdventurerType[],\n  adventurersCopy: AdventurerType[],\n  treasures: TreasureType[],\n  widthMap: number,\n  lengthMap: number,\n) {\n  const adventurersWithMovementForwardCopy = [...adventurersWithMovementForward]\n\n  const mapClone = [...mapCopy]\n\n  const adventurersClone = [...adventurersCopy]\n\n  const treasuresClone = [...treasures]\n\n  const adventurersThatWillMove: AdventurerType[] = checkDuplicateMove(adventurersWithMovementForwardCopy)\n\n  adventurersClone.forEach((adventurer: AdventurerType) => {\n    adventurersThatWillMove.forEach((adventurerMove: AdventurerType) => {\n      if (adventurerMove.id === adventurer.id) {\n        // Old and news Coords of an adventurer\n        const adventurerAfterMoved = moveForward(adventurer, widthMap, lengthMap)\n        const adventurerOldCoords = { ...adventurer }\n\n        const mapBox = mapClone[adventurer.vertically][adventurer.horizontally]\n        const mapBoxAfterMoved = mapClone[adventurerAfterMoved.vertically][adventurerAfterMoved.horizontally]\n        const mapBoxOldCoords = mapClone[adventurerOldCoords.vertically][adventurerOldCoords.horizontally]\n\n        // Mean that the adventurer want to move on a case which contain another adventurer without doesn't have movements anymore\n        if (mapBoxAfterMoved.isAdventurer || mapBoxAfterMoved.type === 'mountain') {\n          adventurer.movements = adventurer.movements.substring(1)\n        }\n        // The adventurer will move on all others cases: plain, treasure\n        else {\n          adventurer.horizontally = adventurerAfterMoved.horizontally\n          adventurer.vertically = adventurerAfterMoved.vertically\n\n          // Move the adventurer on map box with a type Plain or Treasure\n          if (mapBoxAfterMoved.type === 'treasure' || mapBoxAfterMoved.type === 'treasureAdventurer') {\n            if (mapBoxAfterMoved.total) {\n              mapBoxAfterMoved.total -= 1\n              adventurer.treasureRecovered += 1\n\n              // Update a treasure in treasures array\n              treasuresClone.forEach((treasure) => {\n                if (treasure.idTreasure === mapBoxAfterMoved.idTreasure) {\n                  if (treasure.total > 0) treasure.total -= 1\n                }\n              })\n            }\n\n            // Add property of the player in the array case\n            mapBoxAfterMoved.type = 'treasureAdventurer'\n            mapBox.id = adventurer.id\n            mapBox.type = 'adventurer'\n            mapBox.symbol = `A(${adventurer.name})`\n            mapBox.orientation = adventurer.orientation\n            mapBox.movements = adventurer.movements\n            mapBox.priority = adventurer.priority\n            mapBox.treasureRecovered = adventurer.treasureRecovered + 1\n            mapBox.isAdventurer = true\n          }\n\n          // Add properties of the player in an array case of type plain\n          if (mapBoxAfterMoved.type === 'plain') {\n            adventurer.horizontally = adventurerAfterMoved.horizontally\n            adventurer.vertically = adventurerAfterMoved.vertically\n\n            mapClone[adventurerAfterMoved.vertically][adventurerAfterMoved.horizontally] = {}\n            mapBoxAfterMoved.id = adventurer.id\n            mapBoxAfterMoved.type = 'adventurer'\n            mapBoxAfterMoved.symbol = `A(${adventurer.name})`\n            mapBoxAfterMoved.orientation = adventurer.orientation\n            mapBoxAfterMoved.movements = adventurer.movements\n            mapBoxAfterMoved.priority = adventurer.priority\n            mapBoxAfterMoved.treasureRecovered = adventurer.treasureRecovered\n            mapClone[adventurerAfterMoved.vertically][adventurerAfterMoved.horizontally].isAdventurer = true\n          }\n\n          // Reset previous case after adventurer move\n          if (mapBoxOldCoords.type !== 'treasureAdventurer') {\n            mapClone[adventurerOldCoords.vertically][adventurerOldCoords.horizontally] = {\n              type: 'plain',\n              symbol: '*',\n              isAdventurer: false,\n              x: adventurerOldCoords.horizontally,\n              y: adventurerOldCoords.vertically,\n            }\n          }\n\n          // Update treasure box after an adventurer leave it\n          if (mapBoxOldCoords.type === 'treasureAdventurer') {\n            const { idTreasure } = mapClone[adventurerOldCoords.vertically][adventurerOldCoords.horizontally]\n\n            mapClone[adventurerOldCoords.vertically][adventurerOldCoords.horizontally] = {}\n\n            treasuresClone.forEach((treasure: any) => {\n              if (treasure.idTreasure === idTreasure) {\n                mapClone[adventurerOldCoords.vertically][adventurerOldCoords.horizontally] = {\n                  idTreasure: treasure.idTreasure,\n                  type: 'treasure',\n                  symbol: `T(${treasure.total})`,\n                  total: treasure.total,\n                }\n              }\n            })\n          }\n\n          adventurer.movements = adventurer.movements.substring(1)\n        }\n      }\n    })\n  })\n  return { adventurersClone, mapClone }\n}\n\n/**\n * Change adventurer orientation depend on his movement\n *\n * @param {string} firstMovement movement this turn of an adventurer\n * @param {string} orientation orientation of an adventurer\n *\n * @returns {string} return new adventurer orientation\n */\nexport function changeOrientation(firstMovement: string, orientation: string): string {\n  switch (true) {\n    case orientation === 'N' && firstMovement === 'D':\n      return 'E'\n    case orientation === 'N' && firstMovement === 'G':\n      return 'O'\n    case orientation === 'S' && firstMovement === 'D':\n      return 'O'\n    case orientation === 'S' && firstMovement === 'G':\n      return 'E'\n    case orientation === 'E' && firstMovement === 'D':\n      return 'S'\n    case orientation === 'E' && firstMovement === 'G':\n      return 'N'\n    case orientation === 'O' && firstMovement === 'D':\n      return 'N'\n    case orientation === 'O' && firstMovement === 'G':\n      return 'S'\n    default:\n      return ''\n  }\n}\n\n/**\n * Update informations about map, adventurers, treasures depend on adventurer move\n *\n * @param {MapType} map map array multidimensional\n * @param {number} widthMap width of map\n * @param {number} lengthMap length of map\n * @param {AdventurerType} adventurers adventurers array\n * @param {TreasureType} treasures treasures array\n *\n * @returns {MapType, AdventurerType} new map and adventurers array after move\n */\nexport function moveAdventurers({ map, widthMap, lengthMap, adventurers, treasures }: MoveAdventurersType): {\n  mapCopy: MapType\n  adventurersCopy: AdventurerType[]\n} {\n  let adventurersCopy: AdventurerType[] = [...adventurers]\n\n  let adventurersWithMovementForward: AdventurerType[] = []\n\n  let mapCopy: MapType = [...map]\n\n  adventurersCopy.forEach((adventurer: AdventurerType) => {\n    const { movements } = adventurer\n    const firstMovement = movements.slice(0, 1)\n\n    if (firstMovement !== 'A' && firstMovement) {\n      const newOrientation = changeOrientation(firstMovement, adventurer.orientation)\n      adventurer.orientation = newOrientation\n      adventurer.movements = adventurer.movements.substring(1)\n    } else if (firstMovement.length) {\n      adventurersWithMovementForward = [...adventurersWithMovementForward, adventurer]\n    }\n  })\n\n  if (adventurersWithMovementForward.length) {\n    const { adventurersClone, mapClone } = filterMovement(\n      mapCopy,\n      adventurersWithMovementForward,\n      adventurersCopy,\n      treasures,\n      widthMap,\n      lengthMap,\n    )\n\n    adventurersCopy = [...adventurersClone]\n    mapCopy = [...mapClone]\n  }\n\n  return { mapCopy, adventurersCopy }\n}\n","import { ReactElement, useEffect, useState } from 'react'\n\nimport { useGame } from 'context/gameContext'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { v4 as uuid } from 'uuid'\n\nimport { addAdventurer, addMountain, addTreasure } from 'utils/helpers/map'\nimport { moveAdventurers } from 'utils/helpers/map/movements'\n\nimport MapType, { MapComponentType } from 'interfaces/MapType'\n\nconst Map = ({ handleResult }: MapComponentType): ReactElement => {\n  const {\n    widthMap,\n    lengthMap,\n    mountains,\n    treasures,\n    adventurers,\n    isAlreadyAMap,\n    getRemainingMoves,\n    setAdventurers,\n    setisAlreadyAMap,\n  } = useGame()\n\n  const mapDefault = new Array(lengthMap).fill(null).map((_, x: number) =>\n    new Array(widthMap).fill(null).map((__, y: number) => ({\n      type: 'plain',\n      symbol: '*',\n      isAdventurer: false,\n      x: x as number,\n      y: y as number,\n    })),\n  )\n\n  const [map, setMap] = useState<MapType>(mapDefault)\n\n  const [remaininMoves, setRemaininMoves] = useState<number>()\n\n  const resetMap = () => {\n    setMap(mapDefault)\n    setisAlreadyAMap(false)\n  }\n\n  // Gestion de l'ajout des éléments dans la map\n  useEffect(() => {\n    if (isAlreadyAMap) {\n      resetMap()\n    } else {\n      if (mountains) {\n        const newMap = addMountain(map, mountains)\n        setMap([...newMap])\n      }\n      if (treasures) {\n        const newMap = addTreasure(map, treasures)\n        setMap([...newMap])\n      }\n      if (adventurers) {\n        const newMap = addAdventurer(map, adventurers)\n        setMap([...newMap])\n\n        setRemaininMoves(getRemainingMoves())\n      }\n\n      if (adventurers.length === 0) handleResult({ widthMap, lengthMap, mountains, treasures, adventurers })\n    }\n  }, [mountains, treasures, adventurers, isAlreadyAMap])\n\n  // Gestion des mouvements dans la map\n  // eslint-disable-next-line consistent-return\n  useEffect(() => {\n    if (remaininMoves) {\n      const id = setTimeout(() => {\n        const { mapCopy, adventurersCopy } = moveAdventurers({ map, widthMap, lengthMap, adventurers, treasures })\n\n        setMap([...mapCopy])\n        setAdventurers([...adventurersCopy])\n      }, 1000)\n\n      return () => clearTimeout(id)\n    }\n    if (remaininMoves === 0) handleResult({ widthMap, lengthMap, mountains, treasures, adventurers })\n  }, [remaininMoves])\n\n  return (\n    <div className=\"mapContainer\">\n      <div className=\"mapWrapper\">\n        {map &&\n          map.map((items, indexFirst) => {\n            return (\n              <div key={uuid()} className=\"horizontallyContainer\">\n                <div className=\"indexHorizontally\">{indexFirst}</div>\n                <div className=\"mapItemContainer\">\n                  {items.map((subItems, sIndex) => {\n                    return (\n                      <div key={uuid()} className=\"verticallyContainer\">\n                        <div className=\"mapItem\">{subItems.symbol}</div>\n                        {indexFirst === 0 && <div className=\"indexVertically\">{sIndex}</div>}\n                      </div>\n                    )\n                  })}\n                </div>\n              </div>\n            )\n          })}\n      </div>\n    </div>\n  )\n}\n\nexport default Map\n","import AdventurerType from 'interfaces/AdventurerType'\nimport MapType from 'interfaces/MapType'\nimport MountainType from 'interfaces/MountainType'\nimport TreasureType from 'interfaces/TreasureType'\n\nexport function addMountain(map: MapType, mountains: MountainType[]): MapType {\n  const newMap = [...map]\n\n  mountains.forEach((mountain: MountainType) => {\n    newMap[mountain.vertically][mountain.horizontally].type = 'mountain'\n    newMap[mountain.vertically][mountain.horizontally].symbol = 'M'\n  })\n\n  return newMap\n}\n\nexport function addTreasure(map: MapType, treasures: TreasureType[]): MapType {\n  const newMap = [...map]\n\n  treasures.forEach((treasure: TreasureType) => {\n    newMap[treasure.vertically][treasure.horizontally].idTreasure = treasure.idTreasure\n    newMap[treasure.vertically][treasure.horizontally].type = 'treasure'\n    newMap[treasure.vertically][treasure.horizontally].symbol = `T(${treasure.total})`\n    newMap[treasure.vertically][treasure.horizontally].total = treasure.total\n  })\n\n  return newMap\n}\n\nexport function addAdventurer(map: MapType, adventurers: AdventurerType[]): MapType {\n  const newMap = [...map]\n\n  adventurers.forEach((adventurer: AdventurerType) => {\n    newMap[adventurer.vertically][adventurer.horizontally].id = adventurer.id\n    newMap[adventurer.vertically][adventurer.horizontally].name = adventurer.name\n    newMap[adventurer.vertically][adventurer.horizontally].type = 'adventurer'\n    newMap[adventurer.vertically][adventurer.horizontally].symbol = `A(${adventurer.name})`\n    newMap[adventurer.vertically][adventurer.horizontally].orientation = adventurer.orientation\n    newMap[adventurer.vertically][adventurer.horizontally].movements = adventurer.movements\n    newMap[adventurer.vertically][adventurer.horizontally].priority = adventurer.priority\n    newMap[adventurer.vertically][adventurer.horizontally].treasureRecovered = 0\n    newMap[adventurer.vertically][adventurer.horizontally].isAdventurer = true\n  })\n\n  return newMap\n}\n","import { ReactElement } from 'react'\n\nimport { MapElementsOutputType } from 'interfaces/MapType'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { v4 as uuid } from 'uuid'\n\nconst Output = ({ elementsOutput }: Record<string, MapElementsOutputType | undefined | null>): ReactElement => {\n  const map = elementsOutput && elementsOutput.mapLine\n  const mountains = (elementsOutput && elementsOutput.mountainsLine) || null\n  const treasures = (elementsOutput && elementsOutput.treasuresLine) || null\n  const adventurers = (elementsOutput && elementsOutput.adventurersLine) || null\n\n  return (\n    <div className=\"outputWrapper\">\n      <div>{map}</div>\n      {mountains && mountains.map((mountain: string) => <div key={uuid()}>{mountain}</div>)}\n      {treasures && treasures.map((treasure: string) => <div key={uuid()}>{treasure}</div>)}\n      {adventurers && adventurers.map((adventurer: string) => <div key={uuid()}>{adventurer}</div>)}\n    </div>\n  )\n}\n\nexport default Output\n","import AdventurerType from 'interfaces/AdventurerType'\nimport elementsInstructionsValidationType from 'interfaces/ElementsInstructionsValidationType'\nimport MountainType from 'interfaces/MountainType'\nimport TreasureType from 'interfaces/TreasureType'\n\nimport { validateAdventurer, validateMountain, validateTreasure } from 'utils/validations/regex'\n\n/**\n * Gets several lines of string type and transforms it into an array\n * where each line becomes an item.\n *\n * @param {string} instructions Sequence of instructions in string type\n *\n * @returns {Array} Sequence of instructions in array\n */\nexport function instructionsToArray(instructions: string): string[] {\n  const REGEX_DETECT_BREAKLINE = /^/gm\n  const REGEX_DETECT_WHITESPACE = /(\\r\\n|\\n|\\r)/gm\n\n  const instructionsArray = instructions.split(REGEX_DETECT_BREAKLINE)\n  const instructionsWithoutWhitespace = instructionsArray\n    .map((instruction) => instruction.replace(REGEX_DETECT_WHITESPACE, ''))\n    .filter(Boolean)\n\n  return instructionsWithoutWhitespace\n}\n\n/**\n * Gets one line of string type and transforms it into an array\n *\n * @param {string} line line of instruction in string type\n *\n * @returns {Array} Sequence of instructions in array\n */\nexport function stringToArray(line: string): string[] {\n  const array = line.split(/[- ]/).filter(Boolean)\n\n  return array\n}\n\n/**\n * Validate the instruction of the map creation by checking it\n * structure, shape, numbers of cells and elements\n *\n * @param {string} mapInstruction line of map instruction\n * @param {number} instructionsTotal total instructions\n *\n * @returns {Object} Empty object if map instruction isn't correct or not\n */\nexport function mapInstructionValidation(mapInstruction: string, instructionsTotal: number): Record<string, number> {\n  let mapSize = {}\n  // Structure validation\n  const REGEX_STRUCTURE_MAP_VALIDATION = /^[Cc]\\s-\\s[1-9]\\s-\\s[1-9]$/gm\n  const isMapStructureValid = REGEX_STRUCTURE_MAP_VALIDATION.test(mapInstruction)\n\n  // Rectangular shape validation\n  const mapInstructionArray = stringToArray(mapInstruction)\n  const firstNumber = Number(mapInstructionArray[1])\n  const secondNumber = Number(mapInstructionArray[2])\n  const isRectangularMap = firstNumber !== secondNumber\n\n  // Checking the number of cells in the map and the number of elements\n  const cellsTotal = firstNumber * secondNumber\n  const isNumberOfElementsValid = cellsTotal >= instructionsTotal\n\n  const isMapInstructionValid = isMapStructureValid && isRectangularMap && isNumberOfElementsValid\n\n  if (isMapInstructionValid) {\n    mapSize = {\n      width: firstNumber,\n      length: secondNumber,\n    }\n  }\n\n  return mapSize\n}\n\n/**\n * Validate instructions of elements by checking it\n *\n * @param {array} elementsInstructions list of instructions\n * @param {string} mapLineInstruction the instruction line that refers to the size of the map\n *\n * @returns {object} map instruction is correct or not\n */\nexport function elementsInstructionsValidation(\n  elementsInstructions: string[],\n  mapLineInstruction: string,\n): elementsInstructionsValidationType {\n  let isElementsValid = true\n  const mountainsCoords: Array<MountainType> = []\n  const treasuresCoords: Array<TreasureType> = []\n  const adventurerCoords: Array<AdventurerType> = []\n\n  const mapLineInstructionArray = stringToArray(mapLineInstruction)\n  const mapInstructionWidthNumber = Number(mapLineInstructionArray[1]) - 1\n  const mapInstructionLengthNumber = Number(mapLineInstructionArray[2]) - 1\n\n  const coordsElements = elementsInstructions.map((instruction: string, index: number) => {\n    let coords\n\n    const elementInstruction = stringToArray(instruction)\n    const isMapInstruction = /^[Cc]/.test(instruction)\n    const isAdventurerInstruction = /^[Aa]/.test(instruction)\n    const isMountainInstruction = /^[Mm]/.test(instruction)\n    const isTreasureInstruction = /^[Tt]/.test(instruction)\n\n    const isMountainStructureValid = validateMountain(instruction)\n    const isTreasureStructureValid = validateTreasure(instruction)\n    const isAdventurerStructureValid = validateAdventurer(instruction)\n\n    const isOneStructureValid = isMountainStructureValid || isTreasureStructureValid || isAdventurerStructureValid\n\n    const isMountainOrTreasureOutOfMapCoords =\n      Number(elementInstruction[1]) > mapInstructionWidthNumber ||\n      Number(elementInstruction[2]) > mapInstructionLengthNumber\n    const isAdventurerOutOfMapCoords =\n      Number(elementInstruction[2]) > mapInstructionWidthNumber ||\n      Number(elementInstruction[3]) > mapInstructionLengthNumber\n\n    // Check if elements structure are correct\n    if (!isOneStructureValid) isElementsValid = false\n\n    // Check if there is only one C line\n    if (isMapInstruction) isElementsValid = false\n\n    // check if coord element are not out of map coords\n    if ((isMountainInstruction || isTreasureInstruction) && isMountainOrTreasureOutOfMapCoords) isElementsValid = false\n    if (isAdventurerInstruction && isAdventurerOutOfMapCoords) isElementsValid = false\n\n    const indexHorizontally = isAdventurerInstruction ? Number(elementInstruction[2]) : Number(elementInstruction[1])\n    const indexVertically = isAdventurerInstruction ? Number(elementInstruction[3]) : Number(elementInstruction[2])\n\n    // Get coords depends on element type\n    if (isMountainInstruction) {\n      coords = elementInstruction[1] + elementInstruction[2]\n\n      mountainsCoords.push({\n        id: `mountain-${index}`,\n        horizontally: indexHorizontally,\n        vertically: indexVertically,\n        type: 'mountain',\n      })\n    }\n\n    if (isTreasureInstruction) {\n      coords = elementInstruction[1] + elementInstruction[2]\n\n      treasuresCoords.push({\n        idTreasure: `treasure-${index}`,\n        horizontally: indexHorizontally,\n        vertically: indexVertically,\n        total: Number(elementInstruction[3]),\n        type: 'treasure',\n      })\n    }\n\n    if (isAdventurerInstruction) {\n      coords = elementInstruction[2] + elementInstruction[3]\n\n      adventurerCoords.push({\n        id: `adventurer-${index}`,\n        name: elementInstruction[1],\n        horizontally: indexHorizontally,\n        vertically: indexVertically,\n        orientation: elementInstruction[4],\n        movements: elementInstruction[5],\n        priority: index + 1,\n        treasureRecovered: 0,\n        type: 'adventurer',\n      })\n    }\n\n    return coords\n  })\n\n  // check if there is any duplicate coords\n  const isDuplicate = coordsElements.some((item, index) => index !== coordsElements.indexOf(item))\n  if (isDuplicate) isElementsValid = false\n\n  return {\n    mountains: mountainsCoords,\n    treasures: treasuresCoords,\n    adventurers: adventurerCoords,\n    isValid: isElementsValid,\n  }\n}\n\n/**\n * Checks the validity of the data\n *\n * @param {Array} instructions Sequence of instructions in array\n *\n * @returns {boolean} all instructions are valid or not\n */\nexport function instructionsValidation(\n  instructions: string[],\n): { mapValid: Record<string, number>; elementsValid: elementsInstructionsValidationType } | Record<string, never> {\n  const instructionsCopy = [...instructions] // avoid side-effect, no change by reference\n  const mapLineInstruction = instructionsCopy.shift() || ''\n  const fileLineNumbers = instructionsCopy.length\n\n  // Map line validation\n  const mapValid = mapInstructionValidation(mapLineInstruction, fileLineNumbers)\n  const isEmptyMapObect = Object.keys(mapValid).length === 0\n\n  if (isEmptyMapObect) return {}\n\n  // Elements lines validation\n  const elementsValid = elementsInstructionsValidation(instructionsCopy, mapLineInstruction)\n\n  return { mapValid, elementsValid }\n}\n","export function validateMountain(element: string): boolean {\n  const REGEX_MOUNTAIN_VALIDATION = /^[Mm]\\s-\\s[0-9]\\s-\\s[0-9]$/gm\n\n  return REGEX_MOUNTAIN_VALIDATION.test(element)\n}\n\nexport function validateTreasure(element: string): boolean {\n  const REGEX_TREASURE_VALIDATION = /^[Tt]\\s-\\s[0-9]\\s-\\s[0-9]\\s-\\s[1-9]$/gm\n\n  return REGEX_TREASURE_VALIDATION.test(element)\n}\n\nexport function validateAdventurer(element: string): boolean {\n  const REGEX_ADVENTURER_VALIDATION =\n    /^[Aa]\\s-\\s[a-zA-Z]{1,10}\\s-\\s[0-9]\\s-\\s[0-9]\\s-\\s[Nn|Ss|Oo|Ee]\\s-\\s[Aa|Dd|Gg]{1,20}$/gm\n\n  return REGEX_ADVENTURER_VALIDATION.test(element)\n}\n","import { FormEvent, ReactElement, useEffect, useRef, useState } from 'react'\n\nimport { useGame } from 'context/gameContext'\n\nimport { instructionsValidation, instructionsToArray } from 'utils/helpers/form'\n\nimport FormInstructionsType from 'interfaces/FormInstructionsType'\n\nconst FormInstructions = ({ handleMapCreation, resetResult }: FormInstructionsType): ReactElement => {\n  const refTextArea = useRef<HTMLTextAreaElement>(null) // Uncontrolled Components\n  const [createMap, setCreateMap] = useState<boolean>(false)\n\n  const { isAlreadyAMap, setWidthMap, setLengthMap, setMountains, setTreasures, setAdventurers, setisAlreadyAMap } =\n    useGame()\n\n  const handleOnSubmit = (event: FormEvent) => {\n    if (!refTextArea.current) return\n\n    const instructionsArray = instructionsToArray(refTextArea.current.value)\n    const instructions = instructionsValidation(instructionsArray)\n\n    const isInstructionsValid = Object.keys(instructions).length !== 0 && instructions.elementsValid.isValid\n\n    if (isInstructionsValid) {\n      // Reset map\n      if (createMap) setisAlreadyAMap(true)\n\n      setWidthMap(instructions.mapValid.width)\n      setLengthMap(instructions.mapValid.length)\n      setMountains(instructions.elementsValid.mountains)\n      setTreasures(instructions.elementsValid.treasures)\n      setAdventurers(instructions.elementsValid.adventurers)\n\n      setCreateMap(true)\n    }\n\n    event.preventDefault()\n  }\n\n  useEffect(() => {\n    if (createMap) handleMapCreation(createMap)\n\n    resetResult(isAlreadyAMap)\n  }, [createMap, isAlreadyAMap])\n\n  return (\n    <>\n      <form data-test=\"formEntryFile\" className=\"formEntryFileStyle\" onSubmit={handleOnSubmit}>\n        <div>\n          <textarea name=\"textEntryFile\" cols={30} rows={10} ref={refTextArea} />\n        </div>\n        <button type=\"submit\">Valider</button>\n      </form>\n      {/* {createMap !== null && <div className=\"messageForm\">{createMap ? MESSAGE_FILE_SUCCESS : MESSAGE_FILE_ERROR}</div>} */}\n    </>\n  )\n}\n\nexport default FormInstructions\n","import { useState } from 'react'\nimport { GameProvider } from 'context/gameContext'\n\nimport { FormInstructions, Map } from 'components'\nimport Output from 'components/Output'\n\nimport { getResults } from 'utils/helpers/outputResult'\n\nimport 'styles/App.css'\nimport { MapElementsOutputType, MapElementsType } from 'interfaces/MapType'\n\nconst App = () => {\n  const [displayMap, setDisplayMap] = useState(false)\n  const [displayResult, setDisplayResult] = useState(false)\n  const [elementsOutput, setElementsOutput] = useState<MapElementsOutputType | null | undefined>()\n\n  const handleMapCreation = (isInstructionsValid: boolean) => isInstructionsValid && setDisplayMap(true)\n\n  const resetResult = (isAlreadyAMap: boolean) => isAlreadyAMap && setDisplayResult(false)\n\n  const handleResult = (mapElements: MapElementsType) => {\n    const mapElementsOutput = getResults(mapElements)\n\n    setElementsOutput(mapElementsOutput)\n    setDisplayResult(true)\n  }\n\n  return (\n    <div className=\"App\">\n      <GameProvider>\n        <div className=\"GameContainer\">\n          <h1>Treasure map</h1>\n          <div>\n            <FormInstructions handleMapCreation={handleMapCreation} resetResult={resetResult} />\n          </div>\n          {displayMap && <Map handleResult={handleResult} />}\n          {displayResult && (\n            <div className=\"outputContainer\">\n              <h3 className=\"outputTitle\">Résultat</h3>\n              <Output elementsOutput={elementsOutput} />\n            </div>\n          )}\n        </div>\n      </GameProvider>\n    </div>\n  )\n}\n\nexport default App\n","import AdventurerType from 'interfaces/AdventurerType'\nimport { MapElementsType } from 'interfaces/MapType'\nimport MountainType from 'interfaces/MountainType'\nimport TreasureType from 'interfaces/TreasureType'\n\nexport function getResults(mapElements: MapElementsType) {\n  const mapLine = `C - ${mapElements.widthMap} - ${mapElements.lengthMap}`\n  let mountainsLine: string[] = []\n  let treasuresLine: string[] = []\n  let adventurersLine: string[] = []\n\n  if (mapElements.mountains.length) {\n    mountainsLine = mapElements.mountains.map(\n      (mountain: MountainType) => `M - ${mountain.horizontally} - ${mountain.vertically}`,\n    )\n  }\n  if (mapElements.treasures.length) {\n    treasuresLine = mapElements.treasures.map(\n      (treasure: TreasureType) => `T - ${treasure.horizontally} - ${treasure.vertically} - ${treasure.total}`,\n    )\n  }\n  if (mapElements.adventurers.length) {\n    adventurersLine = mapElements.adventurers.map(\n      (adventurer: AdventurerType) =>\n        `A - ${adventurer.name} - ${adventurer.horizontally} - ${adventurer.vertically} - ${adventurer.orientation} - ${adventurer.treasureRecovered}`,\n    )\n  }\n\n  return { mapLine, mountainsLine, treasuresLine, adventurersLine }\n}\n","import { ReportHandler } from 'web-vitals'\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry)\r\n      getFID(onPerfEntry)\r\n      getFCP(onPerfEntry)\r\n      getLCP(onPerfEntry)\r\n      getTTFB(onPerfEntry)\r\n    })\r\n  }\r\n}\r\n\r\nexport default reportWebVitals\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport 'styles/index.css'\r\nimport App from 'pages/App'\r\nimport reportWebVitals from 'reportWebVitals'\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root'),\r\n)\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals()\r\n"],"sourceRoot":""}